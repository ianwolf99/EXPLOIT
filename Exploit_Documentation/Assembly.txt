system organization
+I/O devices
+CPU
+Memory
*are connected by system bus

Structure of the cpu
+Control unit
+Execution unit
+Registers-placeholder memory variables
EAX,EBX,ECX,EDX,ESI/EDI(index registers),ESP,EIP,SS,DSES,CS,FS,GS(segement registers)
+Flags
-indicate events when execution is taking place

*http://resources.
infosecinstitute.com/debugging-fundamentals-forexploit-development/#x86

*A stack is a memory region where all the return addresses,function parameters and local variables of a function are stored

*softwares crash because 41414141 at EIP is not a valid memory address
[+] Metasploit framework
[+] pattern_create.rb
[+] pattern_offset.rb

*./pattern_offset.rb -l <length> -q <Address_of_EIP>

*after running POC script checkout EIP on the debugger 
*On Windbg checkout the stack using
>dd esp
*find JMP ESP instruction from prog or its dlls and supply the address to 42424242
[+]Immunity Debugger
[+] python mona.py script
*!mona modules->will list all the dlls

[+]msfbinscan
*msfbinscan -j esp module.dll
*JMP ESP to jump to the stack

structure
-offset
-JMP ESP(addr)
-NOPs=No Operation instructions /x90
-Shellcode
-junk

*Determining badchars->https://
bulbsecurity.com/finding-bad-characters-withimmunity-debugger-and-mona-py/

*Exception hyandlers are code modules that catch exceptions and errors generated during execution of the program
-allows the program to continue execution instead of crashing.

*Data Execution Prevention(DEP)-is a protection mechanism that marks certain areas of memory No-executable,causing no execution of the shellcode thus making the exploitation to fail

*

[Following Execution]
* reversing any binary on the planet is determining exactly what it is doing
and how it is doing it

->Tracing is the process of executing a program and recording information along the way. The
UNIX command strace runs an executable while intercepting all system calls including passed
args
->Detecting memory corruption is important to the reverse engineer. Stack and heap overÐows
are attacks that overwrite and corrupt memory.
->Microsoft began adding stack cookies to their compiler beginning with Visual Studio
2003, using the GS command line switch
->The cookie is calculated by taking a global security cookie, __security_cookie,
and XORing it with the esp register. During an exit of the function, the stack cookie is
XORed with the esp register. The result of the operation should be __security_cookie. This value
is passed to the __security_check_cookie( ) function. If the passed value matches __security_cookie,
then __security_check_cookie( ) returns allowing the original function to continue as designed
->The idea of the protection is that the cookie check will fail if the stack has been corrupted.
If the check fails, the process will be terminated with an exit code of 0xc0000409. In order to
catch the stack corruption, we can set a breakpoint in __security_check_cookie( ), as shown in
Figure 5.12. Alternately, the breakpoint can be set directly on the __report_gsfailure( ) function.
The __security_check_cookie( ) function is compiled in statically and the address will change
depending on the binary
->, unlike the GS stack protection, the heap protections are part of the operating
system
->The packets have to be read off the network and into the program. There are a limited
number of API calls that accomplish the task. The program can directly make the system calls
itself, but thatís only encountered in malware. The place(s) where the packet is read off the
wire is always a good place to start your analysis. The following is a list of common API calls
capable of reading trafÝc off a network socket.

■ read/write
■ recv/send
■ recvfrom,/sendto
■ WSARecv/WSASend
■ WSARecvFrom/WSASendTo
■ ioctl
■ ioctlsocket
■ WSARecvDisconnect/WSASendDisconnect
■ WSARecvEx/WSASendEx
■ recvmsg/sendmsg
■ WSARecvMsg/WSASendMsg

->ltrace and strace are programs that allow you to view the dynamic library calls
and syscalls that a program makes, as well as view the signals the program
receives. ltrace is exceptionally useful if you’re trying to work out how a particular part of a certain string-handling mechanism works in a target process.
strace is also pretty useful if you’re trying to evade a host-based IDS and need

->http://www.microsoft.com/technet/sysinternals/
default.mspx.
■■ RegMon—Monitors access to the Windows registry, with a filter so that
you can focus on the processes under test.
■■ FileMon—Monitors file activity, again with a useful filter feature.
■■ HandleEx—Views DLLs loaded by a process, as well as all the handles
it has open; for example, named pipes, shared memory sections, and files.
■■ TCPView—Associates TCP and UDP endpoints with the process that
owns them.
■■ Process Explorer—Allows real-time examination of processes, handles,
DLLs, and more
to work out what pattern of syscalls a program makes

->The quickest way to write code is to cut and paste from code that already
works. If you’re writing an exploit, it doesn’t matter so much whether the code
you’re cutting is your own or someone else’s, as long as you understand
exactly what it’s doing. If you don’t understand what a piece of shellcode is
doing, it is probably quicker in the long run to write something to perform that
task yourself, because you’ll then be able to modify it more easily
->Cscope
Cscope is a source code browsing tool that is very useful for auditing large
source code trees. It was originally developed at Bell Labs, and has been
made publicly available under the BSD license by SCO. You can find it at
http://cscope.sourceforge.net/.
->Format strings are very easy to find in an audit. Only a limited number of
functions accept printf-style arguments; it is quite often enough to identify all
calls to these functions and verify whether an attacker can control the format
string. For example, the following vulnerable and non-vulnerable syslog calls
look strikingly different.
Possibly Vulnerable
syslog(LOG_ERR,string);
Non-Vulnerable
syslog(LOG_ERR,”%s”,string);
->Many software developers use define to help organize length sizes in their
programs. Often developers will use the define but unintentionally add a serious vulnerability to their application
->On IDA The display is color-coded to make viewing easier. Constant values are
green, named values are blue, imported functions are pink, and most of the
code is dark blue
->. An example of the C
calling convention is:
some_function(some_pointer,some_integer);
This function call would look something like the following when using the
C calling convention:
push some_integer
push some_pointer
call some_function
add esp,8
->If Statements
if statements are one of the most common C code constructs and sometimes
are very easy to see and interpret in compiled code. They are most often
represented by the CMP or TEST instructions, followed by a conditional jump.
The following example shows a simple C if statement and its corresponding
assembly
int some_int;
if(some_int != 32)
some_int = 32;
Compiled Representation (ebp-4 = some_int):
mov eax, [ebp-4]
cmp eax, 32
jnz past_next_instruction
mov eax, 32
if statements are generally characterized by forward jumps or branches;
however, this is not necessarily true, and reorganization of code by the compiler
can create havoc with this problem. In some contexts, it will be very obvious
that a conditional branch was an if statement, but in other contexts if statements are difficult to differentiate from other code constructs such as loops. A
better understanding of the overall structure of a function should make it clear
where if statements are found.
->For and While Loops
Loop constructs within an application are a very common place to find vulnerabilities. Recognizing them within binaries is often a key part of auditing.
While it’s not really possible to absolutely distinguish different types of loops
from one another in compiled code, recognizing them functionally within
binaries is usually pretty simple. They are generally characterized by a backwards branch or jump that leads to a repeated section of code. The following
example illustrates a simple while loop and its compiled representation.
C Code:
char *ptr,*output,*outputend;
while(*ptr) {
*output++ = *ptr++;
if(output >= outputend)
break;
}
Compiled Representation (ecx = ptr, edx = output, ebp+8 = outputend):
mov al, [ecx]
test al, al
jz loop_end
mov [edx], al
inc ecx
inc edx
cmp edx, [ebp+8]
jae loop_end
jmp loop_begin
The code could have been functionally the same as a simple for loop, which
makes it difficult to determine what kind of statement was in the original
source code. However, the code’s functionality is more important than its original state as source code, and loops like the one shown here are the source of
many errors in closed source applications
->Many compilers will optimize the memcpy library function into some simple
assembly instructions that are much more efficient than a function call. This
type of memory copy operation can potentially be the source of buffer overflow vulnerabilities and can easily be recognized within a disassembly. The set
of instructions used is the following:
mov esi, source_address
mov ebx, ecx
shr ecx, 2 // length divided by four
mov edi, eax // destination address
repe movsd // copy four byte blocks
mov ecx, ebx
and ecx, 3 // remainder size
repe movsb // copy it
In this case, the data is copied from the source register ESI to the destination
register EDI. The data is copied in 4-byte blocks initially for the sake of speed
by the instruction repe movsd. This copies ECX number of 4-byte blocks from
ESI to EDI, which is why the length in ECX is divided by 4. The repe movsb
instruction copies the remainder of the data.
memset is often optimized out in exactly the same manner using the repe
stosd instruction with the AL register holding the character to memset. memmove
is not optimized in this manner due to the possibility of overlapping data
regions
->Some common code constructs are indicative of dangerous code that may
contain buffer overflows. Some examples follow.
A variable indexed write into a character array:
mov [ecx+edx], al
A variable indexed write to a local stack buffer:
mov [ebp+ecx-100h], al
A write to a pointer, followed by an increment of that pointer:
mov [edx], ax
inc edx
inc edx
A sign extended copy from an attacker-controlled buffer:
mov cl, [edx]
movsx eax, cl
An addition to or subtraction from a register containing attacker-controlled
data (leading to an integer overflow):
mov eax, [edi]
add eax, 2
cp eax, 256
jae error
Value truncation as a result of being stored as a 16- or 8-bit integer:
push edi
call strlen
add esp, 4
mov word ptr [ebp-4], ax
By recognizing these code constructs and many like them, it should be possible
to locate a wide range of memory corruption vulnerabilities within binaries
->With ollydbg
http://
malwareanalysis.com/CommunityServer/blogs/geffner/archive/2007/02/
15/18.aspx

->The most trivial overflow bugs happen when an application stores a temporary
buffer in the stack and receives variable-length input from the outside world
into that buffer. The classic case is a function that receives a null-terminated
string as input and copies that string into a local variable. Here is an example
that was disassembled using WinDbg.
Chapter7!launch:
00401060 mov eax,[esp+0x4]
00401064 sub esp,0x64
00401067 push eax
00401068 lea ecx,[esp+0x4]
0040106c push ecx
0040106d call Chapter7!strcpy (00401180)
00401072 lea edx,[esp+0x8]
00401076 push 0x408128
0040107b push edx
Parameter 2
32 bits
Parameter 1
Return Address
Saved EBP
number
string[3]..[7]
string[0]..[3]
counter
CopiedBuffer + 0x18
32 bits
CopiedBuffer + 0x14
CopiedBuffer + 0x10
CopiedBuffer + 0x0C
CopiedBuffer + 0x08
CopiedBuffer + 0x04
CopiedBuffer
counter
Current
Value of
ESP
Current
Value of
EBP
Current
Value of
ESP
Current
Value of
EBP
Before Reading string After Reading string
Auditing Program Binaries 2470040107c call Chapter7!strcat (00401190)
00401081 lea eax,[esp+0x10]
00401085 push eax
00401086 call Chapter7!system (004010e7)
0040108b add esp,0x78
0040108e ret
Before dealing with the specifics of the overflow bug in this code, let’s try to
figure out the basics of this function. The function was defined with the cdecl
calling convention, so the parameters are unwound by the caller. This means
that the RET instruction can’t be used for determining how many parameters the
function takes. Let’s try to figure out the stack layout in this function. Start by
reading a parameter from [esp+0x4], and then subtract ESP by 100 bytes, to
make room for local variables. If you go to the end of the function, you’ll see the
code that moves ESP back to where it was when I first entered the function. This
is the add esp, 0x78, but why is it adding 120 bytes instead of 100? If you look
at the function, you’ll see three function calls to strcpy, strcat, and system.
If you look inside those functions, you’ll see that they are all cdecl functions (as
are all C runtime library functions), and, as already mentioned, in cdecl functions the caller is responsible for unwinding the parameters from the stack. In
this function, instead of adding an add esp, NumberOfBytes after each call,
the compiler has chosen to optimize the unwinding process by simply unwinding the parameters from all three function calls at once.
This approach makes for a slightly less “reverser-friendly” function because
every time the stack is accessed through ESP, you have to try to figure out
where ESP is pointing to for each instruction. Of course, this problem only
exists when you’re studying a static disassembly— on a live debugger, you can
always just look at the value of ESP at any given moment
->There are several simple patterns to look for when searching for a stack overflow vulnerability in a program. The first thing is probably to look at a function’s
stack size
-> This can be identified by looking for a SUB ESP
instruction at the very beginning of the function. Functions that store large
buffers on the stack will usually subtract ESP by a fairly large number
-> Once you’ve
located a function that has a conspicuously large stack space, the next step is to
look for places where a pointer to the beginning of that space is used. This would
typically be a LEA instruction that uses an operand such as [EBP – 0x200], or
[ESP – 0x200], with that constant being near or equal to the specific size of
the stack space allocated.
->Certain processors
provide support for defining memory pages as nonexecutable, which means
that they can only be used for storing data, and that the processor will not run
code stored in them. The operating system can then mark stack and data pages
as nonexecutable, which prevents an attacker from running code on them
using a buffer overflow
->heaps are arranged as linked lists, and the pointers to the
next and previous heap blocks are placed either right before or right after the
actual block data. This means that writing past the end of a heap block would
corrupt that linked list in some way. 
->The idea is that attackers can take advantage of the heap’s linked-list structure
in order to overwrite some memory address in the process’s address space.
Implementing such attacks can be quite complicated, but the basic idea is fairly
straightforward. Because each block in the linked list has “next” and “prev”
members, it is possible to overwrite these members in a way that would allow
the attacker to write an arbitrary value into an arbitrary address in memory.
->heap overflows are usually less common than stack
overflows because the sizes of heap blocks are almost always dynamically calculated to be large enough to fit the incoming data
->Integer overflows (see [Blexim], [Koziol]) are a special type of overflow bug
where incorrect treatment of integers can lead to a numerical overflow which
eventually results in a buffer overflow
->Integer overflows come in many flavors
->program needs to store the usersupplied buffer along with some header or other fixed-sized supplement.
Suppose the program takes the user-supplied length and adds a certain constant
to it—this will typically be a header length of some sort. This can create significant risks because an attacker could take advantage of integer overflows to create a buffer overflow. Here is an example of code that does this sort of thing:
allocate_object:
00401021 push esi
00401022 push edi
00401023 mov edi,[esp+0x10]
00401027 lea esi,[edi+0x18]
0040102a push esi
0040102b call Chapter7!malloc (004010d8)
00401030 pop ecx
00401031 xor ecx,ecx
00401033 cmp eax,ecx
00401035 jnz Chapter7!allocate_object+0x1a (0040103b)
00401037 xor eax,eax
00401039 jmp Chapter7!allocate_object+0x42 (00401063)
0040103b mov [eax+0x4],ecx
0040103e mov [eax+0x8],ecx
00401041 mov [eax+0xc],ecx
00401044 mov [eax+0x10],ecx
00401047 mov [eax+0x14],ecx
0040104a mov ecx,edi
0040104c mov edx,ecx
0040104e mov [eax],esi
00401050 mov esi,[esp+0xc]
00401054 shr ecx,0x2
00401057 lea edi,[eax+0x18]
0040105a rep movsd
0040105c mov ecx,edx
0040105e and ecx,0x3
00401061 rep movsb
00401063 pop edi
00401064 pop esi
00401065 ret
->The preceding contrived, yet somewhat realistic, function takes a buffer
pointer and a buffer length as parameters and allocates a buffer of the length
passed to it via [esp+0x10] plus 0x18 (24 bytes). It then initializes what
appears to be some kind of a buffer in the beginning and copies the user supplied buffer from [esp+0xc] to offset +18 in the newly allocated block (that’s
258 Chapter 7the lea edi,[eax+0x18]). The return value is the pointer of the newly allocated block. Clearly, the idea is that an object is being allocated with a 24-byteslong buffer. The buffer is being zero initialized, except for the first member at
offset +0, which is set to the total size of the buffer allocated. The user-supplied
buffer is then placed after the header in the newly allocated block.
At first glance, this code appears to be perfectly safe because the function
only writes as many bytes to the allocated buffer as it managed to allocate. The
problem is that, as usual, we’re dealing with values coming in from the outside
world; there’s no way of knowing what we’re going to get. In this particular
case, the problem is caused by the arithmetic operation performed on the
buffer length parameter.
The lea esi,[edi+0x18] at address 00401027 seems innocent, but what
happens if EDI contains a very high value that’s close to 0xffffffff? In such
a case, the addition would overflow and the result would be a low positive number, possibly lower than the length of the buffer itself! Suppose, for example, that
you feed the function with 0xfffffff8 as the buffer length. 0xfffffff8 +
0x18 = 0x100000010, but that number is larger than 32 bits. The processor is
truncating the result, and you end up with 0x00000010.
Keeping in mind that the buffer length copied by the function is the original
supplied length (before the header length was added to it), you can now see how
this function would definitely crash. The malloc call will allocate a buffer of
0x10 bytes long, but the function will try to copy 0xfffffff8 bytes to the
newly allocated buffer, thus crashing the program.
->software developers don’t fully understand the semantics of the
programming language they are using. These semantics can be critical because
they define (among other things) how data is going to be handled at a low
level. Type conversion errors take place when developers mishandle incoming
data types and perform incorrect conversions on them
->movsx esi,word ptr [esp+0xc]
This line copies the parameter from the stack into ESI, while treating it as a
signed short and therefore sign extends it. Sign extending means that if the
buffer length parameter has its most significant bit set, it would be converted
into a negative 32-bit number. For example, a buffer length of 0x9400 (which
is 37888 in decimal) would become 0xffff9400 (which is 4294939648 in decimal), instead of 0x00009400
->You have a total of 248 code references to this function, which is effectively
a malloc wrapper function. It is now time to analyze the function FMAlloc to
see how it works.
By looking at FMAlloc’s disassembly, you can see that it starts by checking
to see whether some global pointer is not NULL. This function is used to get a
pointer to the LIBC’s function malloc:
.text:0004D76C ; _DWORD __cdecl FMAlloc(size_t n)
.text:0004D76C public _Z7FMAllocj
.text:0004D76C _Z7FMAllocjproc near ; CODE XREF: FMAlloc(uint)j
.text:0004D76C n = dword ptr 8
.text:0004D76C
.text:0004D76C push ebp
.text:0004D76D mov ebp, esp
.text:0004D76F push edi
.text:0004D770 push esi
.text:0004D771 push ebx
.text:0004D772 sub esp, 0Ch226 
.text:0004D775 call $+5
.text:0004D77A pop ebx
.text:0004D77B add ebx, 11CBAEh
.text:0004D781 mov eax, ds:(g_fileio_ptr - 16A328h)[ebx]
; My guess is that it's returning a pointer to "malloc".
.text:0004D787 mov eax, [eax+24h]
; Is the pointer to malloc NULL?
.text:0004D78A test eax, eax
.text:0004D78C mov edi, [ebp+n]
.text:0004D78F jz short loc_4D7B0
If the function pointer returned in 0x4d787 is not NULL, it continues normally
with the next instruction; otherwise, the branch to 0x4D7B0 is taken. If you
follow this jump, you discover the following code:
.text:0004D7B0 loc_4D7B0: ; CODE XREF: FMAlloc(uint)+23j
.text:0004D7B0 sub esp, 0Ch
.text:0004D7B3 push edi ; size
.text:0004D7B4 call _malloc
.text:0004D7B9 add esp, 0Ch
.text:0004D7BC push edi ; n
.text:0004D7BD push 0 ; c
.text:0004D7BF push eax ; s
.text:0004D7C0 mov esi, eax
.text:0004D7C2 call _memset
.text:0004D7C7 lea esp, [ebp-0Ch]
.text:0004D7CA pop ebx
.text:0004D7CB mov eax, esi
.text:0004D7CD pop esi
.text:0004D7CE pop edi
.text:0004D7CF leave
.text:0004D7D0 retn
.text:0004D7D0 _Z7FMAllocj endp
This part of the code allocates memory as much as specified by the arguments
the function receives (the size is stored in the EDI register) at 0x4D7B3. Then, it
calls memset over the function pointer returned by malloc to initialize the buffer
to 0x00s. There are at least two bugs here. The first one is that there is not a check
for invalid allocation sizes given to the malloc function. You can pass -1, which
is translated to 0xFFFFFFFF in a 32-bit application or 0xFFFFFFFFFFFFFFFF in a
64-bit application, and it tries to allocate 4GB in 32-bit or 16EiB (exbibytes) in
64-bit platforms. Obviously, it simply fails because that is the maximum virtual
memory range that can be addressed. You can also pass zero, which returns a
valid pointer, but any attempt to write anything to that allocated memory risks
corrupting the heap metadata or other previously allocated memory blocks.Chapter 12 ■ Static Analysis 227
The second bug is even easier to spot: there is no check at all after the
malloc call to determine whether it failed. So, if you can pass an invalid size
(such as –1), it causes the malloc function to fail (by returning a null pointer).
Then, FMAlloc continues by calling memset to clear the newly allocated memory pointer. This entire function call is then equivalent to memset(nullptr,
0x00, size_t(-1)), resulting in an access violation exception or a segfault
(segmentation fault).
Okay, so you discovered your first bug in the F-Secure libfm.so library.
What is your next step? It is time to discover whether the function FMAlloc
is called with unsanitized input that is user controlled. The input can come
from reading an input file, while parsing its format, and then some fields are
passed to FMAlloc without further sanitation or checks. Typically, a size field
in a file format that is read and used to allocate memory using FMAlloc is an
interesting target. The function InnoDecoder::IsInnoNew, which is one of the
many cross-references to FMAlloc, is an example of that. In this function, there
are a few calls to initialize internal structures and to read the DOS header
of an InnoSetup-compressed executable, the PE header, and other headers,
as well as InnoSetup’s own header. After such function calls, you have the
following code:
.text:F72E5743 jz short loc_F72E57B1
.text:F72E5745 sub esp, 0Ch
.text:F72E5748 push [ebp+n] ; n
.text:F72E574E call __Z7FMAllocj ; FMAlloc(uint)
.text:F72E5753 add esp, 10h
.text:F72E5756 test eax, eax
.text:F72E5758 mov [ebp+s], eax
.text:F72E575E jz short loc_F72E57B1
.text:F72E5760 push ecx
.text:F72E5761 push [ebp+n] ; n
.text:F72E5767 push 0 ; c
.text:F72E5769 push eax ; s
.text:F72E576A call _memset
.text:F72E576F add esp, 10h
This code calls FMAlloc, passing the argument n. It so happens that n is actually read directly from the file buffer, so by simply setting this 32-bit unsigned
value of the corresponding field in the input file to 0xFFFFFFFF (–1), you trigger
the bug you just uncovered. To test this bug, you have to create (or download)
an InnoSetup and modify the field in question to the value 0xFFFFFFFF. When
a vulnerable (old) version of F-Secure Anti-Virus analyzes such a file, it crashes
because it attempts to write to a null pointer.
You have just discovered an easy remote denial-of-service (DoS) attack vector
in the InnoSetup installer files analyzer code of F-Secure, and that is because o
a buggy malloc wrapper function. The InnoDecoder::IsInnoNew function is just
one vulnerable function. There were many more, such as LoadNextTarFilesChunk,
but according to the vendor they are now all fixed. As an exercise, you can verify
whether this is true.
->When a process starts, the heap manager creates a new heap called the default process heap. C/C++
applications also creates the so-called CRT heap (used by new/delete, malloc/free and their variants). It is
also possible to create other heaps via the HeapCreate API function. The Windows heap manager can be
broken down into two components: the Front End Allocator and the Back End Allocator.
->Starting with Windows Vista, the LAL front end allocator isn’t present anymore and the LFH front end
allocator is used instead. The LFH front end allocator is very complex, but the main idea is that it tries to
reduce the heap fragmentation by allocating the smallest block of memory that is large enough to contain
data of the requested size.
->heap coalescing is also possible: when a block is freed, the heap manager
checks the two adjacent blocks and if one or both of them are free, the free blocks may be coalesced into a
single block. This reduces heap fragmentation
-> For allocations of size greater than 0x7FFF0 bytes the heap
manager sends an explicit allocation request to the virtual memory manager and keeps the allocated blocks
on a list called the virtual allocation list.
->All the memory used by the heap manager is requested from the Windows virtual memory manager. The
heap manager requests big chunks of virtual memory called segments. Those segments are then used by
the heap manager to allocate all the blocks and the internal bookkeeping structures. When a new segment
is created, its memory is just reserved and only a small portion of it is committed. When more memory is
needed, another portion is committed. Finally, when there isn’t enough uncommitted space in the current
segment, a new segment is created which is twice as big as the previous segment. If this isn’t possible
because there isn’t enough memory, a smaller segment is created. If the available space is insufficient even
for the smallest possible segment, an error is returned.
->windbg>dt _PEB @$peb at offset 90
-.the list of heaps is contained in the PEB
->ProcessHeaps points to an array of pointers to HEAP structures (one pointer per heap).
windbg>dd  <addr at Processheaps>
windbg>dt _HEAP <heap_point>
->to display heap structure
->attacking a heap based vulnerability requires
the attacker to overwrite other code pointers
*-Overwritting a function pointer
*-Overwritting heap metadata
->Typically managed by a memory allocation library that offers
functionality to allocate and free chunks of memory (in C:
malloc() and free() calls)
->technique of overwriting a pointer that is later
dereferenced for writing is called indirect pointer
overwrite
•This is a broadly useful attack technique, as it allows to
selectively change memory contents
->virtual
addresses from 0 to 0x7fffffff are in user space, 0x80000000 and above are in
kernel space. On x64, the same concept applies except that user space is from 0
to 0x000007ff`ffffffff and kernel space is 0xffff0800`00000000 and above.
->there is a 64KB
gap between user/kernel space on x86/ARM. This region, usually referred to as the
no-access region, is there so that the kernel does not accidentally cross the address
boundary and corrupt user-mode memory
->Windows kernel exports
two routines to get the current EPROCESS and ETHREAD: PsGetCurrentProcess
and PsGetCurrentThread.
->PsGetCurrentThread proc near
mov rax, gs:188h ; gs:[0] is the PCR, offset 0x180 is the PRCB,
; offset 0x8 into the PRCB is the CurrentThread
field
retn
PsGetCurrentThread endp
PsGetCurrentProcess proc near
mov rax, gs:188h ; get current thread (see above)
mov rax, [rax+0B8h] ; offset 0x70 into the ETHREAD is the associated
; process(actually ETHREAD.ApcState.Process)
retn
PsGetCurrentProcess endp
->A system call is typically a function in the kernel that services I/O
requests from users; it is implemented in the kernel because only high-privilege
code can manage such resources. For example, when a word processor saves a
file to disk, it first needs to request a file handle from the kernel, writes to the
file, and then commits the file content to the hard disk; the OS provides system
calls to acquire a file handle and write bytes to it. While these appear to be
simple operations, the system calls must perform many important tasks in the
kernel to service the request. For example, to get a file handle, it must interact
with the file system (to determine whether the path is valid or not) and then
ask the security manager to determine whether the user has sufficient rights
to access the file; to write bytes to the file, the kernel needs to figure out which
hard drive volume the file is on, send the request to the volume, and package
the data into a structure understood by the underlying hard-drive controller.
All these operations are done with complete transparency to the user.
->Windows describes and stores system call information with two data structures: a service table descriptor and an array of function pointers/offsets. The
service table descriptor is a structure that holds metadata about system calls
supported by the OS; its definition is officially undocumented, but many people
have reverse engineered its important field members as follows. (You can also
figure out these fields by analyzing the KiSystemCall64 or KiSystemService
routines.)
->typedef struct _KSERVICE_TABLE_DESCRIPTOR
{
PULONG Base; // array of addresses or offsets
PULONG Count;
ULONG Limit; // size of the array
PUCHAR Number;
...
} KSERVICE_TABLE_DESCRIPTOR, *PKSERVICE_TABLE_DESCRIPTOR;
Base is a pointer to an array of function pointers or offsets (depending on the
processor); a system call number is an index into this array. Limit is the number of
entries in the array. The kernel keeps two global arrays of KSERVICE_DESCRIPTOR_
DESCRIPTOR: KeServiceDescriptorTable and KeServiceDescriptorTableShadow.
The former contains the native syscall table; the latter contains the same data, in
addition to the syscall table for GUI threads. The kernel also keeps two globalChapter 3 ■ The Windows Kernel 93
pointers to the arrays of addresses/offsets: KiServiceTable points to the non-GUI
syscall table and W32pServiceTable points to the GUI one
->0: kd> dps nt!KeServiceDescriptorTable
81472400 813564d0 nt!KiServiceTable ; Base
81472404 00000000
81472408 000001ad
8147240c 81356b88 nt!KiArgumentTable
0: kd> dd nt!KiServiceTable
813564d0 81330901 812cf1e2 81581540 816090af
813564e0 815be478 814b048f 8164e434 8164e3cb
813564f0 812dfa09 814e303f 814a0830 81613a9f
81356500 814e5b65 815b9e3a 815e0c4e 8158ce33
...
0: kd> dps nt!KiServiceTable
813564d0 81330901 nt!NtWorkerFactoryWorkerReady
813564d4 812cf1e2 nt!NtYieldExecution
813564d8 81581540 nt!NtWriteVirtualMemory
813564dc 816090af nt!NtWriteRequestData94 Chapter 3 ■ The Windows Kernel
813564e0 815be478 nt!NtWriteFileGather
813564e4 814b048f nt!NtWriteFile
However, on x64 and ARM, it is an array of 32-bit integers which encodes the
system call offset and number of arguments passed on the stack. The offset is
contained in the top 20 bits, and the number of arguments on the stack is contained in the bottom 4 bits. The offset is added to the base of KiServiceTable
to get the real address of the syscall. For example:
0: kd> dps nt!KeServiceDescriptorTable
fffff803`955cd900 fffff803`952ed200 nt!KiServiceTable ; Base
fffff803`955cd908 00000000`00000000
fffff803`955cd910 00000000`000001ad
fffff803`955cd918 fffff803`952edf6c nt!KiArgumentTable
0: kd> u ntdll!NtCreateFile
ntdll!NtCreateFile:
000007f8`34f23130 mov r10,rcx
000007f8`34f23133 mov eax,53h ; syscall number
000007f8`34f23138 syscall
...
0: kd> x nt!KiServiceTable
fffff803`952ed200 nt!KiServiceTable (<no parameter info>)
0: kd> dd nt!KiServiceTable + (0x53*4) L1
fffff803`952ed34c 03ea2c07 ; encoded offset and number of arguments
0: kd> u nt!KiServiceTable + (0x03ea2c07>>4) ; get the offset and add it to
Base
nt!NtCreateFile:
fffff803`956d74c0 sub rsp,88h
fffff803`956d74c7 xor eax,eax
fffff803`956d74c9 mov qword ptr [rsp+78h],rax
fffff803`956d74ce mov dword ptr [rsp+70h],20h
0: kd> ? 0x03ea2c07 & 0xf ; number of arguments
Evaluate expression: 7 = 00000000`00000007
; NtCreateFile takes 11 arguments. The first 4 are passed via registers and
; the last 7 are passed on the stack
->Similar to user-mode applications, kernel-mode code can allocate memory at
run-time. The general name for it is pool memory; one can think it like the heap
in user mode
->Paged pool memory is memory that can be paged out at any
given time by the memory manager. When kernel-mode code touches a buffer that is paged out, it triggers a page-fault exception that causes the memory
manager to page in that buffer from disk. Non-paged pool memory is memory
that can never be paged out; in other words, accessing such memory never
triggers a page fault
->Pool memory is allocated and freed by the ExAllocatePool* and ExFreePool*
family of functions. By default, non-paged pool memory (type NonPagedPool) is
mapped with read, write, and execute permission on x86/x64, but non-executable
on ARM; on Windows 8, one can request non-executable, non-paged pool memory
by specifying the NonPagedPoolNX pool type. Paged pool memory is mapped
read, write, executable on x86, but non-executable on x64/ARM.
->A thread is defined by two kernel data structures: ETHREAD and KTHREAD. An
ETHREAD structure contains housekeeping information about the thread (i.e.,
thread id, associated process, debugging enabled/disabled, etc.). A KTHREAD
structure stores scheduling information for the thread dispatcher, such as
thread stack information, processor on which to run, alertable state, and so on.
An ETHREAD contains a KTHREAD.
->A process contains at least one thread and is defined by two kernel data
structures: EPROCESS and KPROCESS. An EPROCESS structure stores basic information about the process (i.e., process id, security token, list of threads, etc.).
A KPROCESS structure stores scheduling information for the process (i.e., page
directory table, ideal processor, system/user time, etc.). An EPROCESS contains a
KPROCESS. Just like ETHREAD and KTHREAD, these data structures are also opaque
and should only be accessed with documented kernel routines
->Processes
kd> dt nt!_EPROCESS
+0x000 Pcb : _KPROCESS
+0x2c8 ProcessLock : _EX_PUSH_LOCK
+0x2d0 CreateTime : _LARGE_INTEGER
+0x2d8 RundownProtect : _EX_RUNDOWN_REF
+0x2e0 UniqueProcessId : Ptr64 Void
+0x2e8 ActiveProcessLinks : _LIST_ENTRY
+0x2f8 Flags2 : Uint4B
+0x2f8 JobNotReallyActive : Pos 0, 1 Bit
+0x2f8 AccountingFolded : Pos 1, 1 Bit
+0x2f8 NewProcessReported : Pos 2, 1 Bit
...108 Chapter 3 ■ The Windows Kernel
+0x3d0 InheritedFromUniqueProcessId : Ptr64 Void
+0x3d8 LdtInformation : Ptr64 Void
+0x3e0 CreatorProcess : Ptr64 _EPROCESS
+0x3e0 ConsoleHostProcess : Uint8B
+0x3e8 Peb : Ptr64 _PEB
+0x3f0 Session : Ptr64 Void
...
0: kd> dt nt!_KPROCESS
+0x000 Header : _DISPATCHER_HEADER
+0x018 ProfileListHead : _LIST_ENTRY
+0x028 DirectoryTableBase : Uint8B
+0x030 ThreadListHead : _LIST_ENTRY
+0x040 ProcessLock : Uint4B
...
+0x0f0 ReadyListHead : _LIST_ENTRY
+0x100 SwapListEntry : _SINGLE_LIST_ENTRY
+0x108 ActiveProcessors : _KAFFINITY_EX
...
Threads
0: kd> dt nt!_ETHREAD
+0x000 Tcb : _KTHREAD
+0x348 CreateTime : _LARGE_INTEGER
+0x350 ExitTime : _LARGE_INTEGER
...
+0x380 ActiveTimerListLock : Uint8B
+0x388 ActiveTimerListHead : _LIST_ENTRY
+0x398 Cid : _CLIENT_ID
...
0: kd> dt nt!_KTHREAD
+0x000 Header : _DISPATCHER_HEADER
+0x018 SListFaultAddress : Ptr64 Void
+0x020 QuantumTarget : Uint8B
+0x028 InitialStack : Ptr64 Void
+0x030 StackLimit : Ptr64 Void
+0x038 StackBase : Ptr64 Void
+0x040 ThreadLock : Uint8B
...
+0x0d8 WaitListEntry : _LIST_ENTRY
+0x0d8 SwapListEntry : _SINGLE_LIST_ENTRY
+0x0e8 Queue : Ptr64 _KQUEUE
+0x0f0 Teb : Ptr64 Void
->An integer overflow occurs when an integer is
increased beyond its maximum value or
decreased beyond its minimum value
->Standard integer types (signed)
 signed char, short int, int, long int, long long int
->An unsigned overflow occurs when the
underlying representation can no longer
represent an integer value.
 A signed overflow occurs when a value is carried
over to the sign bit
->Heap allocators maintain metadata such as
chunk size, previous, and next pointers
 Metadata adjusted during heap‐management
functions
• malloc() and free()
Heap metadata often inlined with heap data
->Use After Free
Error: Program frees memory on the heap,
but then references that memory as if it were
still valid(Indirect Pointer overwrite due to dereferencing while use after free is via referencing freed memory variables)
Adversary can control data written using the
freed pointer
AKA use of dangling pointers
->Type Confusion
Cause the program to process data of one
type when it expects data of another type
Provides the same affect as we did with use‐
after‐free(is a type of type confusion attack)
-> Arguments (up to the first six) are passed
to procedures via registers
– The rest passed through the stack
REVERSING_IE
->some objects to look for wen analyzing
+Array
+LargeHeapBlock
+ArrayBuffer
+Int32Array
SRV*C:\WinDbgSymbols*http://msdl.microsoft.com/download/symbols

<script type="text/javascript"></script>
	alert("Start");
	var a = new Array(0x123;)
	for(var i = 0; i<123; ++i)
	a[i] = 0x111;
	alert("Done")

->look for sequence of 0x111
0:004> s-d 0 L?ffffffff 111 111 111 111
->we got nothing in memory
_Download pdbdumpb for extracting useful information
->The prologue for a function using this traditional stack frame looks like the
following in Intel notation:
push ebp // save the old frame pointer to the stack
mov ebp, esp // set the new frame pointer to esp
sub esp, 5ch // reserve space for local variables
At this point, local stack variables are located at a negative offset to EBP, and
function arguments are located at a positive offset. The first function argument
is found at EBP + 8. IDA Pro will rename the location EBP + 8 to EBP+arg_0.
Nearly all references to arguments and local stack variables will be made
relative to the frame pointer in functions with this frame type. This stack layout has been very well documented and is the easiest to follow when auditing.
Most code generated by MSVC++ and by gcc will make use of this stack frame
*Another form of stack due to compilers
-> Some compilers may even in some
cases use the frame pointer register as a general-purpose register. In this case,
a function will access its arguments and local variables relative to the stack
pointer ESP instead of the frame pointer. Although the frame pointer in a traditional stack frame is constant, the stack pointer floats location throughout
the function, changing every time an operation pushes or pops something
from the stack. The following example attempts to illustrate this:
this_function:
push esi
push edi
push ebx
push dword ptr [esp+10h] // first argument to this_function
push dword ptr [esp+18h] // second argument to this_function
call some_function
-> the strlen code construction may seem strange at first. It
generally looks much like the following:
mov edi, string
or ecx, 0xffffffff
xor eax, eax
repne scasb
not ecx
dec ecx
->The following windows, including their hotkeys when applicable, are exposed
in WinDbg:
■ Command/output window (Alt+1)—This window enables you to type
commands and see the output of operations. While it is possible to debug190 Chapter 4 ■ Debugging and Automation
using other windows and menu items, the command window enables
you to make use of the full power of DbgEng’s built-in commands and
the available extensions.
■ Registers window (Alt+4)—Displays the configured registers. It is possible
to customize this view to control which registers are displayed or hidden.
■ Memory (Alt+5)—Memory dump window. This window enables you
to see the contents of memory, and to scroll, copy, and even edit the
memory contents.
■ Calls (Alt+6)—Displays the call stack information.
■ Disassembly (Alt+7)—Whereas the command window will display the
current instruction disassembly listing, the disassembly window displays
a page worth of disassembled code. In this window it is also possible to
carry out actions with hotkeys:
■ Add or delete breakpoints on the selected line (F9)
■ Process control (stepping/F11, resuming/F5, etc.)
■ Navigation (Page up/Page down to explore disassembled code)
->WinDbg,
you can navigate to the Debug/Event Filters menu to graphically configure the
events
windbg-sx commandS
The d command is used to dump memory contents. The general syntax is as
follows:
d[a|b|c|d|D|f|p|q|u|w|W] [Options] [Range]
Various formats can be used to display memory contents. The most common
formats are as follows:
■ b, w, d, q—For byte, word, double-word, and quad-word format, respectively
■ f, D—For single and double-precision floating-point values, respectively
■ a, u—To display ASCII or Unicode memory contents, respectively
■ p—For pointer values (the size varies according to the current pointer
size of the target
->■ dv [flags] [pattern]—Displays information about local variables
■ x [options] [module_pattern]![symbol_pattern]—Displays symbol(s)
in a given module or modules
■ !dh [options] Address—Dumps PE image headers
■ !drvobj DriverObjectPtr [Flags]—Displays information about a
DRIVER_OBJECT object
->