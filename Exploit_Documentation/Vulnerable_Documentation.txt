-char *gets()
-char *strcpy()
-char *malloc()
-char *strcmp()
-int sprintf()
*A Nop instrction is one byte long.
-wscspy()
-tcscpy()
-mbscpy()
-copymemory()
-HeapAlloc()
-memcpy()
free()
-stpcpy()
-vsprintf()
-strlen()
-memset()
-memmove()
-atoi()
-strdup()
-fclose()
-assert()
-calloc()
-strchr()
-fprintf()
-fscanf()
-scanf()
-sscanf()
-system()
-execl()
-execle()
-popen()
-realloc()
-strcat()
-strncat()
-memchr()
-memcmp()
-fwscan()
-HeapCreate()
-HeapAlloc()
read/write()
recv/send()
recvfrom,/sendto()
WSARecv/WSASend()
WSARecvFrom/WSASendTo()
ioctl()
ioctlsocket()
WSARecvDisconnect/WSASendDisconnect()
WSARecvEx/WSASendEx()
-recvmsg/sendmsg()
WSARecvMsg/WSASendMsg
lstrcpyA
lstrcpyW
->Memset initializes the data
->indicative of dangerous code
+mov [ecx+edx], al
+mov [ebp+ecx-100h], al
+mov [edx], ax
inc edx
inc edx

.sympath
.sympath
.sympath+
Display or set symbol search path
Append directories to previous symbol path
!analyze
!analyze -v
!analyze -hang
!analyze -f
Display information about the current exception or bug check; verbose
User mode: Analyzes the thread stack to determine whether any threads
are blocking other threads.
See an exception analysis even when the debugger does not detect an
exception
->!irp [Address] [Detail] – Displays information about a I/O packet (IRP). Address is the address of the
IRP. The Detail (any number) will display additional information such as owning thread, status ofthe IRP, address of the corresponding MDL and stack locations of the IRP.
!irpfind [-v] [PoolType [Restart Address [Criteria] Data]]] – Searches for a specific IRP matching the
criteria.
PoolType specifies which pool to search through; Restart Address specifies which address to start
at; Criteria specifies which type of data to search for and Data specifies the data to look for e.g.
specific driver name
-v = Displays additional information.
!devobj – Displays information about the _DEVICE_OBJECT data structure.
!drvobj – Displays information about the _DRIVER_OBJECT data structure.
!devnode – Displays information about a device node within the device tree. !devnode 1 will
display all pending removals of device objects, !devnode 2 will show all pending ejects of a device
object and !devnode 0 1 will display the entire device tree.
!devstack [Device Object] – Displays the device stack for a device object. Device Object is the
address of the device object data structure.
Data Structures: _DEVICE_OBJECT, _DRIVER_OBJECT, _IRP, _MDL, _IO_STATUS_BLOCK,
_IO_STACK_LOCATION
Driver Verifier:
!deadlock – Displays information about a deadlock detected by Driver Verifier. Using !deadlock 1
will display the stacks of the deadlocked threads.
!verifier – Shows the status of Driver Verifier. For the flags consult the WinDbg index
->r – Displays the contents of a register.
.trap – Displays a formatted view of the _KTRAP_FRAME data structure with registers.
u – Produces assembly code translation for program code. Use ub for a specific memory range.
Memory Manipulation:
da – Displays the memory contents of an array.
dd – Displays the memory contents within a given address range.
dps – Displays memory with symbol information if possible.
dds – Similar to dps but with Double Word data lengths.
lm display all loaded and unloaded modules
lmv m kernel32 display verbose (all possible) information for kernel32.dll
lmD DML variant of lm!dlls -v -c kernel32 display information for kernel32.dll, including load-count
!lmi kernel32 display detailed information about kernel32, including symbol information
!dh kernel32 display headers for kernel32
->k – Smallest amount of information (ChildEBP (Stack Frame Address), Return Address, Function
Name)
knL – Stack Frame Number, Stack Frame Address, Return Address, Function Name
kb – Stack Frame Address, Return Address, Arguments to the Function, Function Name
kv – Stack Frame Address, Return Address, Arguments to the Function, Function Name , FPO
(Frame Pointer Omission) Optimization, Trap Frames
.frame [/r] [Frame Number] – Displays the current stack frame and registers [/r]
!uniqstack [ -b | -v | -p ] [ -n ] – Displays all stacks for all threads within the current process
->dt ntdll!_HEAP dump _HEAP struct
dt ntdll!_DPH_HEAP_ROOT
dump _DPH_HEAP_ROOT struct.
Enable page heap. Then you can use "!heap -p -all" to get addresses of actual _DPH_HEAP_ROOT structs in your
process.
dt ntdll!
_DPH_HEAP_BLOCK
dump _DPH_HEAP_BLOCK struct.
Enable page heap. Then you can use "!heap -p -all" to get addresses of actual _DPH_HEAP_BLOCK structs in your
process.
!heap list all heaps with index and HeapAddr
!heap -h list all heaps with range information (startAddr, endAddr)
!heap -h 1 detailed heap info for heap with index 1
!heap -s 0 Summary for all heaps (reserved and committed memory, ..)
gflags.exe /i +ust)
!heap -flt s 20 Dump heap allocations of size 20 bytes
!heap -stat Dump HeapHandle list. HeapHandle = value returned by HeapCreate or GetProcessHeap
!heap -stat -h 00150000 Dump usage statistic for HeapHandle = 00150000
!heap 2 -b alloc mtag Breakpoint on HeapAlloc calls with TAG=mtag in heap with index 2
!heap -p Dump heap handle list
!heap -p -a 014c6fb0 Details of heap allocation containing address 014c6fb0 + call-stack if available
!heap -p -all Dump details of all allocations in all heaps in the process
->~* k call stack for all threads ~ !uniqstack
~2 f Freeze Thread TID=2
~# f Freeze the thread causing the current exception
~3 u Unfreeze Thread TID=3
~2e r; k; kd == ~2r; ~2k; ~2kd
~*e !gle will repeat every the extension command !gle for every single thread being debugged
!tls -1 Dump all TLS slots for current thread
!runaway 7 1 (user time) + 2 (kernel time) + 4 (time elapsed since thread start)
!teb Dump formatted view of our threads TEB (only some information)
dt ntdll!_TEB @$teb Dump TEB of current thread
->bp
bp [Addr]
bp [Addr] ["CmdString"]
[~Thrd] bp[#] [Options] [Addr] [Passes]
["CmdString"]
Set breakpoint at address
CmdString = Cmd1; Cmd2; .. Executed every time the BP is hit.
~Thrd == thread that the bp applies too.
# = Breakpoint ID
Passes = Activate breakpoint after #Passes (it is ignored before)
->g go
g `:123`; ? poi(counter); g executes the current program to source line 123; print the value of counter; resume execution
p single step
pr toggle displaying of registers
p 5 "kb" 5x steps, execute "kb" thereafter
pc step to next CALL instruction
pa 7c801b0b step until 7c801b0b is reached
wt trace and watch sub-functions
wt -l 4 -oR trace sub-functions to depth 4, display their return values
->dt ntdll!_PEB* list all variables that contain the word _PEB
dt ntdll!_PEB* -v list with verbose output (address and size included)
dt ntdll!_PEB* -v -s 9 list only symbols whose size is 9 bytes
dt ntdll!_PEB dump _PEB info
dt ntdll!_PEB @$peb dump _PEB for our process
dt ntdll!_PEB 7efde000 dump _PEB at Addr 7efde000
You can get our process's PEB address with "r @$peb" or with "!peb".
dt ntdll!_PEB Ldr SessionId dump only PEB's Ldr and SessionId fields
dt ntdll!_PEB Ldr -y OS* dump Ldr field + all fields that start with OS*
dt mod!var m_cs. dump m_cs and expand its subfields
dt mod!var m_cs.. expand its subfields for 2 levels
dt ntdll!_PEB -r2 dump recursively (2 levels)
dv /t /i /V
dump local variables with type information (/t), addresses and EBP offsets (/V), classify them into categories (/i)
Note: dv will also display the value of a THIS pointer for methods called with the "this calling-convention".
BUG: You must first execute a few commands before dv displays the correct value.
Right at a function's entry point the THIS pointer is present in ECX, so you can easily get it from there.
->HeapHandle = value returned by HeapCreate or GetProcessHeap
For normal heap: HeapHandle == HeapStartAddr Normal & page
HeapAddr = startAddr = NormalHeap Normal & page
UserAddr, UserPtr = value in the range [HeapAlloc...HeapAlloc+AllocSize]
For normal heap this range is further within Heap[startAddr-endAddr] Normal & page
UserSize = AllocSize (value passed to HeapAlloc) Normal & page
_HEAP
= HeapHandle = HeapStartAddr
For every HeapCreate a _HEAP struct is created.
You can use "!heap -p -all" to get these addresses.
Normal heap
_HEAP_ENTRY For every HeapAlloc a _HEAP_ENTRY is created.
You can use "!heap -p -all" to get these addresses. Normal heap
_DPH_HEAP_ROOT
= usually HeapHandle + 0x1000
For every HeapCreate a _DPH_HEAP_ROOT is created.
You can use "!heap -p -all" to get these addresses.
Page heap
_DPH_HEAP_BLOCK For every HeapAlloc a _DPH_HEAP_BLOCK is created.
You can use "!heap -p -all" to get these addresses. Page heap
The display is color-coded to make viewing easier. Constant values are
green, named values are blue, imported functions are pink, and most of the
code is dark blue
->The following windows, including their hotkeys when applicable, are exposed
in WinDbg:
■ Command/output window (Alt+1)—This window enables you to type
commands and see the output of operations. While it is possible to debug190 Chapter 4 ■ Debugging and Automation
using other windows and menu items, the command window enables
you to make use of the full power of DbgEng’s built-in commands and
the available extensions.
■ Registers window (Alt+4)—Displays the configured registers. It is possible
to customize this view to control which registers are displayed or hidden.
■ Memory (Alt+5)—Memory dump window. This window enables you
to see the contents of memory, and to scroll, copy, and even edit the
memory contents.
■ Calls (Alt+6)—Displays the call stack information.
■ Disassembly (Alt+7)—Whereas the command window will display the
current instruction disassembly listing, the disassembly window displays
a page worth of disassembled code. In this window it is also possible to
carry out actions with hotkeys:
■ Add or delete breakpoints on the selected line (F9)
■ Process control (stepping/F11, resuming/F5, etc.)
■ Navigation (Page up/Page down to explore disassembled code)
->Loop constraints within an application is a perfect place for vulnerabilities
->On character array
->When fuzzing look for EAX,ECX and EIP
->Memory management is very error prone..thus overflows
->Interesting memory locations
•  Code addresses or function pointers
–  Return address of a function invocation
–  Function pointers in the virtual function table
–  Program specific function pointers
•  Pointers where the attacker can control what is
written when the program dereferences the
pointer
–  Indirect pointer overwrite: first redirect the pointer to
another interesting location, then write the
appropriate value
char onstack[8];
#ifdef BAD
 /*
 * This first sprintf is bad behavior. Do not use sprintf!
 */
 sprintf(onstack, “%s, %s”, arbitrary_string, and_another);

->some objects to look for wen analyzing
+Array
+LargeHeapBlock
+ArrayBuffer
+Int32Array
->!reg hivelist – Displays HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\hivelist
!reg dumppool – Displays paged pool consumption of registry hives.
!reg viewlist – Displays the mapped views for a selected hive.
!reg freebins – Displays free hive bins.
!reg openkeys – Displays open keys.
!reg kcb – Displays the Key Control Block for a registry key, this will require the use of !reg findkcb.
!reg findkcb – This will give the address of the KCB for the specified file path of the registry key.
!reg cellindex – Gives information corresponding to a cell index.
Data Structures: _CMHIVE, _HHIVE, _CM_CELL_DATA, _CM_KEY_CONTROL_BLOCK,
_CM_KEY_HASH, _HMAP_DIRECTORY, _HMAP_TABLE, _HMAP_TABLE_ENTRY
->
Linux is open-source, so an attacker who reads this code in Linux source code (or any software code for that matter) can write exploit code to take advantage of the flaw and execute kernel actions without necessary privileges.
->When the indexes or cut conditions in iterative loops are badly programmed, it can result in more bytes being copied than was intended: either one byte (off-by-one) or several (off-by-a-few)
->Loops that parse strings or handle user inputs tend to be good places to look for vulnerabilities, as shown in the below example, again taken from the University of Washington’s IMAP server (CVE-2005-2933):